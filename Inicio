#include <zephyr/kernel.h>
#include <zephyr/device.h>
#include <zephyr/drivers/uart.h>
#include <zephyr/drivers/gpio.h>
#include <zephyr/sys/printk.h>
#include <zephyr/sys/__assert.h>
#include <zephyr/random/random.h>
#include <string.h>

int i, n=9, ordem, num_chars;
int tempo_incremento = 0, tempo_total=0, tempo_espera=10;
char u = 0b01010101, sync = 0b01100110, Start = 0b00000010, id = 0b10011000, Endtx=0b00000011;
char saveu=0b01010101, saveS = 0b01100110, saveStx=0b00000010, saveI = 0b10011000, saveEtx = 0b00000011;
char testu, testS, testStx, testId, testdata[100], testEtx;
char data[7];

bool Transmitindo = false;


#define UART_DEVICE_NODE DT_CHOSEN(zephyr_shell_uart)

#define MSG_SIZE 8

K_MUTEX_DEFINE (PodeTransmitir);
K_MUTEX_DEFINE (TransmitiuCerto);
K_MUTEX_DEFINE (ESPERA);
K_FIFO_DEFINE (FifoTX);
K_FIFO_DEFINE (FifoRX);
K_MSGQ_DEFINE(uart_msgq, MSG_SIZE, 10, 4);

static const struct device *const uart_dev = DEVICE_DT_GET(UART_DEVICE_NODE);
static char rx_buf[MSG_SIZE];
static int rx_buf_pos;
const struct device * stx = DEVICE_DT_GET(DT_NODELABEL(gpiob));


void serial_cb(const struct device *dev, void *user_data) {
	uint8_t c;

	while (uart_fifo_read(uart_dev, &c, 1) == 1) {
		if ((c == '\n' || c == '\r') && rx_buf_pos > 0) {
			rx_buf[rx_buf_pos] = '\0';
			k_msgq_put(&uart_msgq, &rx_buf, K_NO_WAIT);
			rx_buf_pos = 0;
		} else if (rx_buf_pos < (sizeof(rx_buf) - 1)) {
			rx_buf[rx_buf_pos++] = c;
		}
	}
}


void print_uart(char *buf) {
	int msg_len = strlen(buf);
	for (int i = 0; i < msg_len; i++) {
		uart_poll_out(uart_dev, buf[i]);
	}
}
char caractere[100];

void Tx (void) {
    gpio_pin_configure(stx, 0x0, GPIO_OUTPUT);

    if (!Transmitindo) {
        if (k_mutex_lock(&PodeTransmitir, K_NO_WAIT)==0) {
            Transmitindo = true;
            ordem=1;
        }
        else {
            return;
        }
    }
    //Se não tem ninguém transmitindo, inicia a transmissão

    while (Transmitindo) {
        if (ordem == 1) {
            gpio_pin_set (stx, 0x0, (u&0b10000000)>>7);
            //printk ("%d\n", (u&0b10000000)>>7);
            u=u<<1;
            i++;
            if (i==8) {
                //printk ("U recebido!\n\n");
                ordem=2;
                i=0;
                u=saveu;
            }
        } 

        if (ordem == 2) {
            gpio_pin_set (stx, 0x0, (sync&0b10000000)>>7);
            //printk ("%d\n", (sync&0b10000000)>>7);
            sync=sync<<1;
            i++;
            if (i==n) {
                //printk ("Sync recebido!\n\n");
                ordem=3;
                i=0;
                sync=saveS;
            }
        }

        if (ordem == 3) {
            gpio_pin_set (stx, 0x0, (Start&0b10000000)>>7);
            //printk ("%d\n", (Start&0b10000000)>>7);
            Start=Start<<1;
            i++;
            if (i==n) {
                //printk ("Start Of Transmission!\n\n");
                ordem=4;
                i=0;
                Start=saveStx;
            }
        }

        if (ordem == 4) { 
            gpio_pin_set(stx, 0x0, (id & 0b10000000) >> 7);
            //printk("%d\n", (id & 0b10000000) >> 7);
            id = id << 1;
            i++;
            if (i == 6) {
                //printk("ID Recebido!\n");

                num_chars = strlen(caractere);
                //printk("Quantidade de caracteres: %d\n", num_chars);

                for (int bit_pos = 2; bit_pos >= 0; bit_pos--) {
                    int bit2 = (num_chars >> bit_pos) & 0b00000001;
                    gpio_pin_set(stx, 0x0, bit2);
                    k_msleep(10);
                    //printk("%d", bit2);
                }
                //printk("\nDados: \n");
                for (int j = 0; caractere[j] != '\0'; j++) {
                    for (int k = 7; k >= 0; k--) {
                        int bit1 = (caractere[j] >> k) & 0b00000001;
                        //printk("%d", bit1);
                        gpio_pin_set(stx, 0x0, bit1);
                        k_msleep(10);
                    }
                    printk("\n");
                }
                id=saveI;
                ordem = 5;
                i = 0;
                }
            }


        if (ordem == 5) {
            gpio_pin_set (stx, 0x0, (Endtx&0b10000000)>>7);
            //printk ("%d\n", (Endtx&0b10000000)>>7);
            Endtx=Endtx<<1;
            i++;
            if (i==n) {
                ordem=6;
                i=0;
                Endtx=saveEtx;
            }
        }

        if (ordem == 6) {
            //printk ("Acabou\n");
            k_msleep(10);
            gpio_pin_set (stx, 0x0, 1);
            k_mutex_unlock(&PodeTransmitir);
        }
        k_msleep(10);
    }
}


char tx_buf[MSG_SIZE];

int main(void) {
    caractere[MSG_SIZE - 1] = '\0';

    uart_irq_callback_user_data_set(uart_dev, serial_cb, NULL);
    uart_irq_rx_enable(uart_dev);

    printk ("\n");

    while (1) {  
        if (k_msgq_get(&uart_msgq, &tx_buf, K_FOREVER) == 0) {
            print_uart("Echo: ");
            print_uart(tx_buf);
            print_uart("\r\n");

            strncpy(caractere, tx_buf, MSG_SIZE);
            
            Tx();
            k_msgq_cleanup (&uart_msgq);
        }
    }
    return 0;
}

char palavra;
char dumb, nc;
int z=0, v=0;

bool verificar_dados() {
    return (testu == saveu) &&
           (testS == saveS) &&
           (testStx == saveStx) &&
           (testId == saveI) &&
           (memcmp(testdata, caractere, sizeof(testdata)) == 0) &&
           (testEtx == saveEtx);
}

void Rx() {
    gpio_pin_configure(stx, 0x1, GPIO_INPUT);
    while (1) {
        dumb = (dumb << 1) | gpio_pin_get(stx, 0x1);

        if (ordem == 2 && dumb == saveS) {
            testS = dumb;
            printk("\nSincronizacao recebida!\n");
            z++;
        }
        if (ordem == 3 && dumb == saveStx) {
            testStx = dumb;
            printk("\nInício da Transmissao!\n");
            z++;
        }
        if (ordem == 4) {
            printk ("\nID:");
            for (int t=0;t<5;t++) {
                printk ("%d", gpio_pin_get (stx, 0x1));
                k_msleep (10);
            }
            for (int w=0;w<3;w++) {
                k_msleep (10);
            }
            v=dumb&0b00000111;
            testId=dumb&0b11111000;
            printk("\nQuantidade de caracteres: %d\n", v);
            printk ("\nMensagem:\n");

            for (int s = 0; s < v; s++) {
                for (int q = 0; q < 8; q++) {
                    palavra = (palavra << 1) | gpio_pin_get(stx, 0x1);
                    k_msleep(10);
                }
                testdata[s] = palavra;
                printk("%c", palavra);
            }
            z++;
        }
        if (ordem == 5 && dumb == saveEtx) {
            testEtx = dumb;
            printk("\nETX recebido!\n");
            z++;
        }

        if (ordem == 6) {
            if (verificar_dados()) {
                printk("\nTransmissao Bem-sucedida!\n");
                ordem = 0;
                Transmitindo = true;
            } else {
                printk("\nErro na Transmissao!\n");
                ordem = 0;
                Transmitindo = false;
                caractere[MSG_SIZE - 1] = '\0';
                strncpy(caractere, tx_buf, MSG_SIZE);
                Tx();
            }
        }
        k_msleep(10);
    }
}


K_THREAD_DEFINE(Rx_id, 1024, Rx, NULL, NULL, NULL,
		0, 0, 0);

